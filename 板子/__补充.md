# [图论]

## [圆方树模板]

```C++
void tarjan(int u) { //tarjan 求出点的双连通分量，G 中存储的即为圆方树中的边
	dfn[u] = low[u] = ++cnt;
	stk.push_back(u);
	for(int v : g[u]) {
		if(!dfn[v]) {
			tarjan(v);
			low[u] = min(low[u], low[v]);
			if(low[v] == dfn[u]) {
				sz++;
				G[n + sz].push_back(u);
				G[u].push_back(n + sz);
				int x;
				do {
					x = stk.back(); stk.pop_back();
					G[x].push_back(n + sz);
					G[n + sz].push_back(x);
				} while(x != v);
			}
		} else {
			low[u] = min(low[u], dfn[v]);
		}
	}
}
```
---
## 例题
### [Acwing2863. 最短路](https://www.acwing.com/problem/content/2866/)
```C++
#include <bits/stdc++.h>
#define x first
#define y second
using namespace std;

typedef long long LL;
typedef pair<int, int> PII;
const int INF = 0x3f3f3f3f;
const int N = 12010, M = N * 3;

int n, m, q, cnt, nn;
int dis[N], dep[N], pre[N], fw[N], fe[N];
int fa[N][14], s[N], stot[N];
int dfn[N], low[N];
int A, B;
int h1[N], h2[N], w[M], e[M], ne[M], idx;

void add(int h[], int a, int b, int c) {
	e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx++;	
}

void build_circle(int x, int y, int w) {
	int sum = w;
	nn++;
	for(int k = y; k != x; k = pre[k]) {
		s[k] = sum;
		sum += fw[k];
	}
	s[x] = stot[x] = sum;
	add(h2, x, nn, 0);
	for(int k = y; k != x; k = pre[k]) {
		stot[k] = sum;
		add(h2, nn, k, min(s[k], sum - s[k]));
	}
}

void tarjan(int u, int from) {
	dfn[u] = low[u] = ++cnt;
	for(int i = h1[u]; ~i; i = ne[i]) {
		int v = e[i];
		if(!dfn[v]) {
			pre[v] = u, fw[v] = w[i], fe[v] = i;
			tarjan(v, i);
			low[u] = min(low[u], low[v]);
			if(dfn[u] < low[v]) { //u - v 这条边是桥，直接加到圆方树中
				add(h2, u, v, w[i]);
			}
		} else if(i != (from ^ 1)) {
			low[u] = min(low[u], dfn[v]);
		}
	}
	for(int i = h1[u]; ~i; i = ne[i]) {
		int v = e[i];
		if(dfn[u] < dfn[v] && fe[v] != i) { // u -> u 是一个环, v 在环上
			build_circle(u, v, w[i]);
		}
	}
}

void dfs_lca(int u, int father) {
	dep[u] = dep[father] + 1;
	fa[u][0] = father;
	for(int k = 1; k < 14; k++) {
		fa[u][k] = fa[fa[u][k - 1]][k - 1];
	}
	for(int i = h2[u]; ~i; i = ne[i]) {
		int v = e[i];
		dis[v] = dis[u] + w[i];
		dfs_lca(v, u);
	}
}

int get_lca(int a, int b) {
	if(dep[a] < dep[b]) swap(a, b);
	for(int k = 13; k >= 0; k--) {
		if(dep[fa[a][k]] >= dep[b]) {
			a = fa[a][k];
		}
	}
	if(a == b) return a;
	for(int k = 13; k >= 0; k--) {
		if(fa[a][k] != fa[b][k]) {
			a = fa[a][k];
			b = fa[b][k];
		}
	}
	A = a, B = b;
	return fa[a][0];
}

void solve() {
	cin >> n >> m >> q;
	memset(h1, -1, sizeof h1);
	memset(h2, -1, sizeof h2);
	nn = n;
	while(m--) {
		int u, v, w;
		cin >> u >> v >> w;
		add(h1, u, v, w);
		add(h1, v, u, w);
	}
	tarjan(1, -1);
	dfs_lca(1, 0);
	while(q--) {
		int u, v;
		cin >> u >> v;
		int lca = get_lca(u, v);
		if(lca <= n) {
			cout << dis[u] + dis[v] - dis[lca] * 2 << '\n';
		} else {
			int ans = dis[u] - dis[A] + dis[v] - dis[B];
			int t = abs(s[A] - s[B]);
			ans += min(t, stot[A] - t);
			cout << ans << '\n';
		}
	}
}	

int main() {	
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	int t = 1;
//	cin >> t;
	while(t--) {
		solve();
	}
	return 0;
}
```
---
## [[ABC318G] Typical Path Problem](https://www.luogu.com.cn/problem/AT_abc318_g)
```C++
#include <bits/stdc++.h>
#define x first
#define y second
using namespace std;

typedef long long LL;
typedef pair<int, int> PII;
const int INF = 0x3f3f3f3f;
const int N = 200010, M = N * 2;

int n, m, a, b, c, sz;
int dfn[N], low[N], cnt;
int fa[N];
vector<int> g[N], G[M], stk;

void tarjan(int u) {
	dfn[u] = low[u] = ++cnt;
	stk.push_back(u);
	for(int v : g[u]) {
		if(!dfn[v]) {
			tarjan(v);
			low[u] = min(low[u], low[v]);
			if(low[v] == dfn[u]) {
				sz++;
				G[n + sz].push_back(u);
				G[u].push_back(n + sz);
				int x;
				do {
					x = stk.back(); stk.pop_back();
					G[x].push_back(n + sz);
					G[n + sz].push_back(x);
				} while(x != v);
			}
		} else {
			low[u] = min(low[u], dfn[v]);
		}
	}
}

void dfs(int u, int father) {
	fa[u] = father;
	for(int v : G[u]) {
		if(v != father) {
			dfs(v, u);
		}
	}
}

bool check(int u) {
	while(u != c) {
		if(u > n) {
			for(int v : G[u]) {
				if(v == b) return true;
			}
		}
		u = fa[u];
	}	
	return false;
}

void solve() {
	cin >> n >> m >> a >> b >> c;
	while(m--) {
		int u, v;
		cin >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	tarjan(1);
	dfs(c, -1);
	cout << (check(a) ? "Yes\n" : "No\n");
}	

int main() {	
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	int t = 1;
//	cin >> t;
	while(t--) {
		solve();
	}
	return 0;
}
```
---