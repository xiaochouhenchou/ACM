## 2. 数据结构
### 2.1 $st$ 表

#### [洛谷P3865. ST 表——st表模板题](https://www.luogu.com.cn/problem/P3865)
```C++
#include <iostream>
#define endl "\n"
using namespace std;

const int N = 100010, M = 20;

int n, m;
int a[N];
int f[N][M];
int lg[N];

void init()
{
	for(int j = 0; j < 17; j++)
		for(int i = 1; i + (1 << j) - 1 <= n; i++)
			if(!j) f[i][j] = a[i];
			else f[i][j] = max(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
	for(int i = 2; i <= n; i++) lg[i] = lg[i >> 1] + 1;	
}

int query(int l, int r)
{
	int len = r - l + 1, k = lg[len];
	return max(f[l][k], f[r - (1 << k) + 1][k]);
}

int main()
{
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> n >> m;
	for(int i = 1; i <= n; i++) cin >> a[i];
	init();
	while(m--)
	{
		int l, r;
		cin >> l >> r;
		cout << query(l, r) << endl;
	}
	return 0;
}
```
---
#### [软院2022天梯赛选拔M. 静态区间最大公约数](https://oj.socoding.cn/contest/problem?id=456&pid=12)
```C++
#include <iostream>
#include <queue>
#include <map>
#define endl "\n"
#define x first
#define y second
using namespace std;

const int N = 100010, M = 17;
typedef long long LL;

int n, m;
int a[N], lg[N];
int f[N][M];

int gcd(int a, int b)
{
	return b ? gcd(b, a % b) : a;
}

void init()
{
	for(int i = 2; i <= n; i++) lg[i] = lg[i >> 1] + 1;
	for(int j = 0; j <= M; j++)
		for(int i = 1; i + (1 << j) - 1 <= n; i++)
			if(!j) f[i][j] = a[i];
			else f[i][j] = gcd(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
}

int query(int l, int r)
{
	int len = r - l + 1, k = lg[len];
	return gcd(f[l][k], f[r - (1 << k) + 1][k]);
}

void solve()
{
	cin >> n >> m;
	for(int i = 1; i <= n; i++) cin >> a[i];
	init();
	while(m--)
	{
		int l, r;
		cin >> l >> r;
		cout << query(l, r) << endl;
	}
}
int main()
{
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	solve();
	return 0;
}
```
---

### 2.2 并查集

#### 模板
```C++
struct dsu {
	vector<int> p;
	dsu() {}
	dsu(int n) {
		p.resize(n + 1);
		for(int i = 1; i <= n; i++) {
			p[i] = i;
		}
	}
	int find(int u) {
		return p[u] = (p[u] != u ? find(p[u]) : u);
	}
	bool same(int u, int v) {
		return find(u) == find(v);
	}
	void merge(int u, int v) {
		u = find(u);
		v = find(v);
		if(u != v) {
			p[u] = v;
		}
	}
};
```
---
#### 食物链——维护子节点到根节点的距离
```C++
#include <bits/stdc++.h>
using namespace std;

const int N = 50010;

int n, k;
int p[N], d[N];

int find(int x) {
    if(p[x] != x) {
        int t = find(p[x]);
        d[x] += d[p[x]];
        p[x] = t;
    }
    return p[x];
}

int main() {
    scanf("%d%d", &n, &k);
    for(int i = 1; i <= n; i++) {
        p[i] = i;
    }
    int res = 0;
    while(k--) {
        int t, x, y;
        scanf("%d%d%d", &t, &x, &y);
        if(x > n || y > n) {
            res++;
        }
        else {
            int px = find(x), py = find(y);
            if(t == 1) {
                if(px == py && (d[x] - d[y]) % 3) res++;
                else if(px != py) {
                    p[px] = py;
                    d[px] = d[y] - d[x];
                }
            }
            else {
                if(px == py && (d[x] - d[y] - 1) % 3) res++;
                else if(px != py) {
                    p[px] = py;
                    d[px] = d[y] + 1 - d[x];
                }
            }
        }
    }
    printf("%d\n", res);
    return 0;
}
```
---

### 2.3 队列

#### 单调队列滑动窗口
```C++
#include <bits/stdc++.h>
using namespace std;

const int N = 1000010;

int n, k;
int a[N], q[N];

int main() {
    cin >> n >> k;
    for(int i = 0; i < n; i++) {
        scanf("%d", &a[i]);
    }
    int hh = 0, tt = -1;
    for(int i = 0; i < n; i++) {
        //判断hh是否已经滑出窗口 
        if(i - k + 1 > q[hh]) {
            hh++;
        }
        while(hh <= tt && a[q[tt]] >= a[i]) {
            tt--;
        }
        q[++tt] = i;
        if(i >= k - 1) {
            printf("%d ", a[q[hh]]);
        }
    }
    puts("");
    hh = 0, tt = -1;
    for(int i = 0; i < n; i++) {
        //判断hh是否已经滑出窗口 
        if(i - k + 1 > q[hh]) {
            hh++;
        }
        while(hh <= tt && a[q[tt]] <= a[i]) {
            tt--;
        }
        q[++tt] = i;
        if(i >= k - 1) {
            printf("%d ", a[q[hh]]);
        }
    }    
    return 0;
}
```
---

### 2.4 栈

#### 单调栈——找每个数左边第一个比它小的数
```C++
#include <bits/stdc++.h>
using namespace std;

const int N = 100010;

int n;
int stk[N], tt;

int main() {
    cin >> n;
    while(n--) {
        int x;
        scanf("%d", &x);
        while(tt && stk[tt] >= x) {
            tt--;
        }
        if(tt) cout << stk[tt] << ' ';
        else cout << "-1 ";

        stk[++tt] = x;
    }
    return 0;
}

```
---

### 2.5 树状数组

注意树状数组下标必须从 $1$ 开始，如果从 $0$ 开始就死循环了。

#### 模板
```C++
int lowbit(int x) 
{
    return x & -x;
}

//sum of [1,x]
int sum(int x)
{
    int res = 0;
    for(int i = x; i; i -= lowbit(i)) res += tr[i];
    return res;
}

//add c to the value at the position x
void add(int x, int c)
{
    for(int i = x; i <= n; i += lowbit(i)) tr[i] += c;
}

struct bitTree {
	int n;
	vector<LL> tr;
	bitTree() {}
	bitTree(int sz) : n(sz) {
		tr.resize(n + 1);
		fill(tr.begin(), tr.end(), 0);
	}
	int lowbit(int x) {
		return x & -x;
	}
	//add v to the value at the position x
	void add(int x, int v) {
		for(int i = x; i <= n; i += lowbit(i)) {
			tr[i] += v;
		}
	}
	//sum of [1, x]
	LL sum(int x) {
		LL res = 0;
		for(int i = x; i; i -= lowbit(i)) {
			res += tr[i];
		}
		return res;
	}
};
```
---
#### 区间修改，单点查询——树状数组+差分
```C++
#pragma GCC optimize(3)
#include <iostream>
#define endl "\n"
using namespace std;

const int N = 100010;
typedef long long LL;

int n, m;
LL a[N], b[N];

int lowbit(int x)
{
    return x & -x;
}

void init()
{
    for(int i = 1; i <= n; i++) b[i] = a[i] - a[i - 1];
    for(int i = 1; i <= n; i++)
    {
        for(int j = i - 1; j > i - lowbit(i); j -= lowbit(j))
            b[i] += b[j];
    }
}

void add(int x, int c)
{
    for(int i = x; i <= n; i += lowbit(i)) b[i] += c;
}

LL sum(int x)
{
    LL res = 0;
    for(int i = x; i; i -= lowbit(i)) res += b[i];
    return res;
}

int main()
{
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >> a[i];
    init();
    while(m--)
    {
        char op[2];
        cin >> op;
        if(*op == 'C')
        {
            int l, r, v;
            cin >> l >> r >> v;
            add(l, v), add(r + 1, -v);
        }
        else 
        {
            int x;
            cin >> x;
            cout << sum(x) << endl;
        }
    }
    return 0;
}
```
---
#### 区间修改、区间查询——树状数组
```C++
#pragma GCC optimize(3)
#include <iostream>
#define endl "\n"
using namespace std;

const int N = 100010;
typedef long long LL;

int n, m;
int a[N];
LL b[N], tr[N];

int lowbit(int x)
{
    return x & -x;
}

void init()
{
    for(int i = 1; i <= n; i++)
    {
        b[i] = a[i] - a[i - 1];
        tr[i] = i * b[i];
        for(int j = i - 1; j > i - lowbit(i); j -= lowbit(j))
            b[i] += b[j], tr[i] += tr[j];
    }
}

void add(LL t[], int x, LL c)
{
    for(int i = x; i <= n; i += lowbit(i)) t[i] += c;
}

LL sum(LL t[], int x)
{
    LL res = 0;
    for(int i = x; i; i -= lowbit(i)) res += t[i];
    return res;
}

LL sum(int x)
{
    return sum(b, x) * (x + 1) - sum(tr, x);
}

int main()
{
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >> a[i];
    init();
    while(m--)
    {
        char op[2];
        int l, r, v;
        cin >> op >> l >> r;
        if(*op == 'C')
        {
            cin >> v;
            add(b, l, v), add(b, r + 1, -v);
            add(tr, l, (LL)l * v), add(tr, r + 1, (LL)(r + 1) * (-v));
        }
        else cout << sum(r) - sum(l - 1) << endl;
    }
    return 0;
}
```
---
#### [洛谷P4514. 上帝造题的七分钟——二维差分+树状数组](https://www.luogu.com.cn/problem/P4514)

和一维差分类似，二维差分是二维前缀和的逆运算。

令 $b_{i,j} = a_{i,j} - a_{i - 1, j} - a_{i, j - 1} + a_{i - 1, j - 1}$，那么 $\sum_{i = 1}^{n}\sum_{j = 1}^{m}b_{i, j} = a_{n, m}$。

![由矩阵a构造差分矩阵b](https://pic4.zhimg.com/80/v2-77a7b389c096f32a127703f0dbbe102f.jpg)

那么操作一就变得简单了：如果我们要修改左上角 $(a,b)$，右下角为 $(c,d)$ 的矩阵，只需要 `add(a, b, v),add(c + 1, b, -v), add(a, d + 1, -v), add(c + 1, d + 1, v)` 即可。

![操作一](https://pic4.zhimg.com/80/v2-df902b269fae66db724ae2b113c6aad6.jpg)

操作二需要求 $\sum_{i = a}^{c} \sum_{j = b}^{d} a_{i, j}$，我们来推一下式子。
$$
\sum_{i = a}^{c} \sum_{j = b}^{d} a_{i, j} = \sum_{i = 1}^{c}\sum_{j = 1}^{d}a_{i, j} - \sum_{i = 1}^{a - 1}\sum_{j = 1}^{d}a_{i,j} - \sum_{i = 1}^{c}\sum_{j = 1}^{b - 1}a_{i,j} + \sum_{i = 1}^{a - 1}\sum_{j = 1}^{b - 1}a_{i, j}
$$

由此运算转化为了求矩阵 $a$ 的前缀和，而 $a_{i,j}$ 也是 $b$ 的前缀和，因此可以继续推式子。

$$
\sum_{i=1}^{x}\sum_{j=1}^{y}a_{i,j} = \sum_{i = 1}^{x}\sum_{j = 1}^{y}\sum_{k = 1}^{i}\sum_{u = 1}^{j}b_{k, u}\\
=\sum_{i=1}^{x}\sum_{j = 1}^{y}b_{i,j} * (x - i + 1) * (y - j + 1)\\
=(x + 1)(y + 1)\sum_{i = 1}^{x}\sum_{j = 1}^{y}b_{i, j} - (x + 1)\sum_{i = 1}^{x}\sum_{j = 1}^{y}b_{i, j} * j \\ - (y + 1)\sum_{i = 1}^{x}\sum_{j = 1}^{y}b_{i, j} * i + \sum_{i = 1}^{x}\sum_{j = 1}^{y}b_{i, j} * ij
$$

看不懂这个式子推导的，可以先推推这个式子。
$$
\sum_{i = 1}^{x}\sum_{j = 1}^{i} b_i = \sum_{i = 1}^{x}(x - i + 1)b_i = (x + 1)\sum_{i = 1}^{x}b_i - \sum_{i = 1}^{x}b_i * i
$$

有了上述推导之后，我们只需要用四个树状数组维护式子四个前缀和即可。

```C++
#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstring>
#define y second
#define x first
#define endl "\n"
using namespace std;

const int N = 2050;

int n, m;
int t1[N][N], t2[N][N], t3[N][N], t4[N][N];

int lowbit(int x)
{
	return x & -x;
}

void add(int a, int b, int v)
{
	for(int i = a; i <= n; i += lowbit(i))
		for(int j = b; j <= m; j += lowbit(j))
		{
			t1[i][j] += v;
			t2[i][j] += b * v;
			t3[i][j] += a * v;
			t4[i][j] += a * b * v;
		}
}

int sum(int a, int b)
{
	int res = 0, v1 = 0, v2 = 0, v3 = 0, v4 = 0;
	for(int i = a; i; i -= lowbit(i))
		for(int j = b; j; j -= lowbit(j))
		{
			v1 += t1[i][j];
			v2 += t2[i][j];
			v3 += t3[i][j];
			v4 += t4[i][j];
		}
	res = v1 * (a + 1) * (b + 1) - (a + 1) * v2 - (b + 1) * v3 + v4;
	return res;
}

void solve()
{
	int a, b, c, d, v;
	char op[2];
	cin >> op >> n >> m;
	while(cin >> op >> a >> b >> c >> d)
	{
		if(*op == 'L')
		{
			cin >> v;
			add(a, b, v); add(a, d + 1, -v);
			add(c + 1, b, -v); add(c + 1, d + 1, v);	
		}
		else 
		{
			int ans = sum(c, d);
			ans -= sum(a - 1, d); ans -= sum(c, b - 1);
			ans += sum(a - 1, b - 1);
			cout << ans << endl;
		}
	}
}
int main()
{
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	solve();
	return 0;
}
```
----

### 2.6 线段树
#### [洛谷P1253. [yLOI2018] 扶苏的问题——线段树区间推平、区间加、区间最值](https://www.luogu.com.cn/problem/P1253)

用两个懒标记 $assg、add$ 分别表示区间赋值、区间加，然后重写 $pushdown$ 函数。因为区间赋值之后，原来的区间加就没有意义了，因此每次区间赋值我们下传两个懒标记到子节点的时候，如果 $assg$ 标记存在的话，我们都将子节点原来的 $add$ 标记清空。然后原来的区间加下传 $add$ 标记的操作还是和原来一致。

记得 $pushdown$ 时候先下传 $assg$ 标记，再下传 $add$ 标记，不然 $add$ 标记可能先被清空了。

代码中可以用一个超出数据修改范围的值来表示 $assg$ 标记是否存在。

```C++
#include <iostream>
#define endl "\n"
using namespace std;

const int N = 1000010;
typedef long long LL;
const LL INF = 1e18;

int n, m;
LL w[N];
struct node
{
	LL l, r, mx, add, assg;
}tr[N * 4];

void pushup(int u)
{
	tr[u].mx = max(tr[u << 1].mx, tr[u << 1 | 1].mx);
}

void pushdown(int u)
{
	auto &root = tr[u], &le = tr[u << 1], &ri = tr[u << 1 | 1];
	if(root.assg != INF)
	{
		le.mx = le.assg = root.assg;
		ri.mx = ri.assg = root.assg;
        //记得清空子节点原来的add标记
		le.add = ri.add = 0;
		root.assg = INF;
	}
	if(root.add)
	{
		le.add += root.add, le.mx += root.add;
		ri.add += root.add, ri.mx += root.add;
		root.add = 0;
	}
}

void build(int u, int l, int r)
{
	tr[u] = {l, r, w[r], 0, INF};
	if(l == r) return;
	int mid = (l + r) >> 1;
	build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
	pushup(u);
}

void update(int u, int l, int r, LL x, bool add)
{
	if(l <= tr[u].l && tr[u].r <= r)
	{
		if(add) tr[u].add += x, tr[u].mx += x;
        //这里也记得清空add标记!!
		else tr[u].assg = tr[u].mx = x, tr[u].add = 0;
		return;
	}
	pushdown(u);
	int mid = (tr[u].l + tr[u].r) >> 1;
	if(l <= mid) update(u << 1, l, r, x, add);
	if(r > mid) update(u << 1 | 1, l, r, x, add);
	pushup(u);
}

LL query(int u, int l, int r)
{
	if(l <= tr[u].l && tr[u].r <= r) return tr[u].mx;
	pushdown(u);
	int mid = (tr[u].l + tr[u].r) >> 1;
	LL res = -INF;
	if(l <= mid) res = max(res, query(u << 1, l, r));
	if(r > mid) res = max(res, query(u << 1 | 1, l, r));
	return res;
}

int main()
{
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> n >> m;
	for(int i = 1; i <= n; i++) cin >> w[i];
	build(1, 1, n);
	while(m--)
	{
		int op, l, r, x;
		cin >> op >> l >> r;
		if(op == 1)
		{
			cin >> x;
			update(1, l, r, x, false);
		}
		else if(op == 2)
		{
			cin >> x;
			update(1, l, r, x, true);
		}
		else cout << query(1, l, r) << endl;
	}
	return 0;
}
```
---
#### [洛谷P2574. XOR的艺术——线段树区间取反、区间求和](https://www.luogu.com.cn/problem/P2574)

我们用一个懒标记 $op$ 表示要不要取反，$1$ 表示需要，$0$ 表示不需要。然后因为只有 $0$ 和 $1$，因此我们修改区间的 $1$ 的个数的时候，只需要将 $1$ 的个数 $sum$ 变成 $len - sum$ 即可，其中 $len$ 为区间的长度（因为原来的 $0$ 的个数为 $len - sum$，因此原来的 $0$ 变成 $1$ 后现在的 $1$ 的个数即为 $len - sum$）。另外懒标记的修改只需要在原来的懒标记的基础上取反即可。

```C++
#include <iostream>
#define endl "\n"
using namespace std;

const int N = 200010;
typedef long long LL;

int n, m;
char s[N];
struct node
{
	int l, r, sum, op;
}tr[N * 4];

void pushup(int u)
{
	tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;	
}

void build(int u, int l, int r)
{
	tr[u] = {l, r, s[r] - '0', 0};
	if(l == r) return;
	int mid = (l + r) >> 1;
	build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
	pushup(u);
}

void pushdown(int u)
{
	auto &root = tr[u], &le = tr[u << 1], &ri = tr[u << 1 | 1];
	if(root.op)
	{
		le.sum = (le.r - le.l + 1) - le.sum, le.op ^= 1;
		ri.sum = (ri.r - ri.l + 1) - ri.sum, ri.op ^= 1;		
		root.op = 0;		
	}
}

void update(int u, int l, int r)
{
	if(l <= tr[u].l && tr[u].r <= r)
	{
		int len = tr[u].r - tr[u].l + 1;
		tr[u].sum = len - tr[u].sum;
		tr[u].op ^= 1;		
		return;
	}
	pushdown(u);
	int mid = (tr[u].l + tr[u].r) >> 1;
	if(l <= mid) update(u << 1, l, r);
	if(r > mid) update(u << 1 | 1, l, r);
	pushup(u);
}

int query(int u, int l, int r)
{
	if(l <= tr[u].l && tr[u].r <= r) return tr[u].sum;
	pushdown(u);
	int mid = (tr[u].l + tr[u].r) >> 1;
	int res = 0;
	if(l <= mid) res += query(u << 1, l, r);
	if(r > mid) res += query(u << 1 | 1, l, r);
	return res;
}

void solve()
{
	cin >> n >> m >> (s + 1);
	build(1, 1, n);
	while(m--)
	{
		int op, l, r;
		cin >> op >> l >> r;
		if(op) cout << query(1, l, r) << endl;
		else update(1, l, r);
	}
}

int main()
{
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	solve();
	return 0;
}
```
---
#### [洛谷P4145 上帝造题的七分钟 2 / 花神游历各国——区间开方、线段树剪枝](https://www.luogu.com.cn/problem/P4145)
题意：求区间和、给某个区间开方。
```C++
#include <iostream>
#include <cmath>
#define endl "\n"
using namespace std;

typedef long long LL;
const int N = 100010;

int n, m;
LL a[N];
struct node
{
	int l, r, flag;
	LL sum;
}tr[N * 4];

void pushup(int u)
{
	tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;
	tr[u].flag = tr[u << 1].flag && tr[u << 1 | 1].flag;
}

void build(int u, int l, int r)
{
	tr[u].l = l, tr[u].r = r;
	if(l == r)
	{
		tr[u].flag = a[r] == 1;
		tr[u].sum = a[r];
		return;
	}
	int mid = (l + r) >> 1;
	build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
	pushup(u);
}

void update(int u, int l, int r)
{
	if(tr[u].flag) return;
	
	if(tr[u].l == tr[u].r)
	{
		tr[u].sum = sqrt(tr[u].sum);
		tr[u].flag = tr[u].sum == 1;
		return;
	}
	
	int mid = (tr[u].l + tr[u].r) >> 1;
	if(l <= mid) update(u << 1, l, r);
	if(r > mid) update(u << 1 | 1, l, r);
	pushup(u);
}

LL query(int u, int l, int r)
{
	if(l <= tr[u].l && tr[u].r <= r) return tr[u].sum;
	int mid = (tr[u].l + tr[u].r) >> 1;
	LL res = 0;
	if(l <= mid) res += query(u << 1, l, r);
	if(r > mid) res += query(u << 1 | 1, l, r);
	return res;
}

int main()
{
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> n;
	for(int i = 1; i <= n; i++) cin >> a[i];
	
	build(1, 1, n);
	
	cin >> m;
	while(m--)
	{
		int op, l, r;
		cin >> op >> l >> r;
		if(l > r) swap(l, r);
		if(!op) update(1, l, r);
		else cout << query(1, l, r) << endl;
	}
	
	return 0;
}
```
---
#### [E. Li Hua and Array——线段树、欧拉函数](https://codeforces.com/contest/1797/problem/E)

我们可以想象一棵以 $1$ 为根节点的树，其中 $\phi(x)$ 是 $x$ 的父节点。

那么涉及区间修改的，可以用线段树来维护。但是注意到每个数只会被修改 $log$ 次，每一次修改 $x$ 都会在上述的树中变成它的父节点，并且每个数变成 $1$ 之后再修改也是 $1$，因此就没必要再修改了。因此我们直接单点修改即可，不需要给区间加修改的懒标记，但是可以加一个标记，表示区间中的数是否全部为 $1$。这样的话如果遇到有标记的区间我们直接返回，达到一个剪枝的效果。

对于操作二，相当于找出区间中每个数在我们假想的树上的 $LCA$。我们直接用线段树维护一个区间的数的 $LCA$：整个区间的 $LCA$ 等于左儿子的 $LCA$ 和右儿子的 $LCA$ 的 $LCA$，直接搞一个 $while$ 循环，两个儿子的轮流跳到它们的父节点，知道父节点相同为止。这个操作可以放在 $pushup$ 函数里。然后询问的时候直接输出我们维护的 $LCA$ 即可。

```C++
#include <iostream>
#define endl "\n"
using namespace std;

const int M = 5000010, N = 100010;

int n, m, pc;
int phi[M], p[M], a[N];
bool st[M];
struct node
{
    //mx 是区间所有数的 LCA
    //cnt 是区间所有数到达LCA mx 的操作次数
    //len 是区间长度
    //flag 是区间标记，表示区间所有数是否为 1
	int l, r, cnt, mx, len, flag;
}tr[N * 4];

//计算欧拉函数
void init(int n)
{
	phi[1] = 1;
	for(int i = 2; i <= n; i++)
	{
		if(!st[i]) 
		{
			phi[i] = i - 1;
			p[pc++] = i;
		}
		for(int j = 0; p[j] <= n / i; j++)
		{
			st[i * p[j]] = true;
			if(i % p[j] == 0)
			{
				phi[i * p[j]] = p[j] * phi[i];
				break;
			}
			phi[i * p[j]] = (p[j] - 1) * phi[i];
		}
	}
}

void pushup(node &root, node &le, node &ri)
{
	root.len = le.len + ri.len;
	root.flag = le.flag && ri.flag;
	root.cnt = le.cnt + ri.cnt;
	
	int x = le.mx, y = ri.mx;
    //暴力跳出 x 、y 的LCA
	while(x != y)
	{
		if(x > y) x = phi[x], root.cnt += le.len;
		else y = phi[y], root.cnt += ri.len;
	}
	root.mx = x;
}

void pushup(int u)
{
	pushup(tr[u], tr[u << 1], tr[u << 1 | 1]);	
}

void build(int u, int l, int r)
{
	if(l == r)
	{
		tr[u] = {l, r, 0, a[r], 1, a[r] == 1};
		return;
	}
	tr[u] = {l, r};
	int mid = (l + r) >> 1;
	build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
	pushup(u);
}

void update(int u, int l, int r)
{
	if(tr[u].flag) return;
	
	if(tr[u].l == tr[u].r)
	{
		tr[u].mx = phi[tr[u].mx];
		tr[u].flag = (tr[u].mx == 1);
		return;
	}
	
	int mid = (tr[u].l + tr[u].r) >> 1;
	if(l <= mid) update(u << 1, l, r);
	if(r > mid) update(u << 1 | 1, l, r);
	pushup(u);
}

node query(int u, int l, int r)
{
	if(l <= tr[u].l && tr[u].r <= r) return tr[u];
	
	int mid = (tr[u].l + tr[u].r) >> 1;
	if(r <= mid) return query(u << 1, l, r);
	if(l > mid) return query(u << 1 | 1, l, r);
	node res, le = query(u << 1, l, r), ri = query(u << 1 | 1, l, r);
	pushup(res, le, ri);
	return res;
}
int main()
{
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	init(5e6);
	cin >> n >> m;
	for(int i = 1; i <= n; i++) cin >> a[i];
	build(1, 1, n);
	
	while(m--)
	{
		int op, l, r;
		cin >> op >> l >> r;
		if(op == 1) update(1, l, r);
		else cout << query(1, l, r).cnt << endl;
	}																																
	return 0;
}
```
---

### 2.7 可持久化数据结构
#### [洛谷P4735 最大异或和——可持久化Trie](https://www.luogu.com.cn/problem/P4735)
```C++
#include <iostream>
#define endl "\n"
using namespace std;

const int N = 600010, M = N * 25;

int n, m, idx, s[N];
int root[N], tr[M][2];
int mx_id[M];

void insert(int i, int j, int p, int q)
{
	if(j < 0)
	{
		mx_id[q] = i;
		return;
	}
	
	int v = s[i] >> j & 1;
	if(tr[p][v ^ 1]) tr[q][v ^ 1] = tr[p][v ^ 1];
	tr[q][v] = ++idx;
	insert(i, j - 1, tr[p][v], tr[q][v]);
	mx_id[q] = max(mx_id[tr[q][0]], mx_id[tr[q][1]]);
}

int query(int l, int r, int c)
{
	int p = root[r];
	for(int i = 23; i >= 0; i--)
	{
		int v = c >> i & 1;
		if(tr[p][v ^ 1] && mx_id[tr[p][v ^ 1]] >= l) p = tr[p][v ^ 1];
		else p = tr[p][v];
	}
	return c ^ s[mx_id[p]];
}

int main()
{
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> n >> m;
	
	root[0] = ++idx;
	insert(0, 23, 0, root[0]);
	
	for(int i = 1; i <= n; i++)
	{
		cin >> s[i];
		s[i] ^= s[i - 1];
		root[i] = ++idx;
		insert(i, 23, root[i - 1], root[i]);
	}
	while(m--)
	{
		char op[2];
		int l, r, x;
		cin >> op >> l;
		if(*op == 'A') 
		{
			n++;
			root[n] = ++idx;
			s[n] = s[n - 1] ^ l;
			insert(n, 23, root[n - 1], root[n]);
		}
		else 
		{
			cin >> r >> x;
			cout << query(l - 1, r - 1, s[n] ^ x) << endl;
		}
	}
}
```
---
#### 可持久化线段树（主席树）
##### [P3919 【模板】可持久化线段树 1（可持久化数组](https://www.luogu.com.cn/problem/P3919)
```C++
#include <iostream>
#define endl "\n"
using namespace std;

const int N = 1000010;

int n, m, idx, a[N], root[N];
struct node
{
	int l, r, v;
}tr[N * 4 + N * 20];

int build(int l, int r)
{
	int p = ++idx;	
	if(l == r)
	{
		tr[p].v = a[r];
		return p;
	}
	int mid = (l + r) >> 1;
	tr[p].l = build(l, mid), tr[p].r = build(mid + 1, r);
	return p;
}

int update(int p, int l, int r, int x, int v)
{
	int q = ++idx;
	tr[q] = tr[p];
	if(l == r)
	{
		tr[q].v = v;
		return q;
	}
	
	int mid = (l + r) >> 1;
	if(x <= mid) tr[q].l = update(tr[p].l, l, mid, x, v);
	else tr[q].r = update(tr[p].r, mid + 1, r, x, v);
	return q;
}

int query(int &q, int p, int l, int r, int x)
{
	q = ++idx;
	tr[q] = tr[p];
	if(l == r) return tr[p].v;
	int mid = (l + r) >> 1;
	if(x <= mid) return query(tr[q].l, tr[p].l, l, mid, x);
	else return query(tr[q].r, tr[p].r, mid + 1, r, x);
}

int main()
{
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> n >> m;
	for(int i = 1; i <= n; i++) cin >> a[i];
	
	int cur = 0;
	root[cur] = build(1, n);
	
	while(m--)
	{
		int p, op, x, v;
		cin >> p >> op >> x;
		if(op == 1)
		{
			cin >> v;
			root[++cur] = update(root[p], 1, n, x, v);
		}
		else cout << query(root[++cur], root[p], 1, n, x) << endl;
	}
	return 0;
}
```
----
##### [洛谷P3834 【模板】可持久化线段树 2——区间第 $k$ 大数查询](https://www.luogu.com.cn/problem/P3834)
```C++
#include <iostream>
#include <algorithm>
#define endl "\n"
using namespace std;

const int N = 200010;

int n, m, idx, t;
int a[N], b[N], root[N];
struct node
{
	int l, r, cnt;	
}tr[N * 4 + N * 18];

int build(int l, int r)
{
	int p = ++idx;	
	if(l == r) return p;
	int mid = (l + r) >> 1;
	tr[p].l = build(l, mid), tr[p].r = build(mid + 1, r);
	return p;
}

int insert(int p, int l, int r, int x)
{
	int q = ++idx;
	tr[q] = tr[p];
	if(l == r)
	{
		tr[q].cnt++;
		return q;
	}
	
	int mid = (l + r) >> 1;
	if(x <= mid) tr[q].l = insert(tr[p].l, l, mid, x);
	else tr[q].r = insert(tr[p].r, mid + 1, r, x);
	tr[q].cnt = tr[tr[q].l].cnt + tr[tr[q].r].cnt;
	return q;
}

int query(int p, int q, int l, int r, int k)
{
	if(l == r) return r;
	int mid = (l + r) >> 1;	
	int cnt = tr[tr[q].l].cnt - tr[tr[p].l].cnt;
	if(cnt >= k) return query(tr[p].l, tr[q].l, l, mid, k);
	else return query(tr[p].r, tr[q].r, mid + 1, r, k - cnt);
}

int main()
{
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> n >> m;
	for(int i = 1; i <= n; i++) cin >> a[i], b[i] = a[i];
	sort(b + 1, b + 1 + n);
	t = unique(b + 1, b + 1 + n) - b - 1;
	for(int i = 1; i <= n; i++)
		a[i] = lower_bound(b + 1, b + 1 + t, a[i]) - b;
	
	root[0] = build(1, t);
	for(int i = 1; i <= n; i++) 
		root[i] = insert(root[i - 1], 1, t, a[i]);
	
	while(m--)
	{
		int l, r, k;
		cin >> l >> r >> k;
		cout << b[query(root[l - 1], root[r], 1, t, k)] << endl;
	}
	return 0;
}
```
---
##### [洛谷P2633 Count on a tree——前缀和、主席树](https://www.luogu.com.cn/problem/P2633)

题意：求从 $u$ 到 $v$ 的路径上的第 $k$ 大点权。
```C++
#include <iostream>
#include <algorithm>
#define endl "\n"
using namespace std;

const int N = 100010, M = N * 2;

int n, m, cnt, t;
int h[N], e[M], ne[M], idx, tol;
int a[N], b[N], id[N], sz[N];
int top[N], fa[N], son[N];
int root[N];
struct node
{
	int l, r, cnt;
}tr[N * 4 + N * 17];

void add(int a, int b)
{
	e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

void init()
{
	sort(b + 1, b + 1 + n);
	t = unique(b + 1, b + 1 + n) - b - 1;
	for(int i = 1; i <= n; i++) 
		a[i] = lower_bound(b + 1, b + 1 + t, a[i]) - b;
}

int build(int u, int l, int r)
{
	int p = ++tol;
	tr[p] = {l, r};
	if(l == r) return p;
	int mid = (l + r) >> 1;
	tr[p].l = build(u << 1, l, mid);
	tr[p].r = build(u << 1 | 1, mid + 1, r);
	return p;
}

int insert(int p, int l, int r, int x)
{
	int q = ++tol;
	tr[q] = tr[p];
	if(l == r)
	{
		tr[q].cnt++;
		return q;
	}
	int mid = (l + r) >> 1;
	if(x <= mid) tr[q].l = insert(tr[p].l, l, mid, x);
	else tr[q].r = insert(tr[p].r, mid + 1, r, x);
	tr[q].cnt = tr[tr[q].l].cnt + tr[tr[q].r].cnt;
	return q;
}

int query(int a, int b, int c, int d, int l, int r, int k)
{
	if(l == r) return r;
	int mid = (l + r) >> 1;
	int la = tr[a].l, lb = tr[b].l, lc = tr[c].l, ld = tr[d].l;
	int ra = tr[a].r, rb = tr[b].r, rc = tr[c].r, rd = tr[d].r;
	int cnt = tr[la].cnt + tr[lb].cnt - tr[lc].cnt - tr[ld].cnt;
	
	if(cnt >= k) return query(la, lb, lc, ld, l, mid, k);
	else return query(ra, rb, rc, rd, mid + 1, r, k - cnt);
}

void dfs1(int u, int father)
{
	sz[u] = 1, fa[u] = father;
	root[u] = insert(root[father], 1, t, a[u]);
	for(int i = h[u]; i != -1; i = ne[i])
	{
		int j = e[i];
		if(j == father) continue;
		dfs1(j, u);
		sz[u] += sz[j];
		if(sz[son[u]] < sz[j]) son[u] = j;
	}
}

void dfs2(int u, int t)
{
	id[u] = ++cnt, top[u] = t;
	if(!son[u]) return;
	dfs2(son[u], t);
	for(int i = h[u]; i != -1; i = ne[i])
	{
		int j = e[i];
		if(j == fa[u] || j == son[u]) continue;
		dfs2(j, j);
	}
}

int get_lca(int u, int v)
{
	while(top[u] != top[v])
	{
		if(id[top[u]] < id[top[v]]) swap(u, v);
		u = fa[top[u]];
	}
	return (id[u] < id[v] ? u : v);
}

int query_path(int u, int v, int k)
{
	int lca = get_lca(u, v);
	return query(root[u], root[v], root[lca], root[fa[lca]], 1, t, k);
}

int main()
{
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> n >> m;
	for(int i = 1; i <= n; i++) cin >> a[i], b[i] = a[i];
	for(int i = 1; i <= n; i++) h[i] = -1;
	for(int i = 1; i <= n - 1; i++)
	{
		int a, b;
		cin >> a >> b;
		add(a, b), add(b, a);
	}
	init();
	root[0] = build(1, 1, t);
	
	dfs1(1, 0);
	dfs2(1, 1);

	int last = 0;
	while(m--)
	{
		int u, v, k;
		cin >> u >> v >> k;
		u ^= last;
		cout << (last = b[query_path(u, v, k)]) << endl;
	}
	return 0;
}
/*
  1
2 	3 	4
  5 6 7  8
 */
```
---

### 2.8 平衡树Splay
#### [洛谷P3391 【模板】文艺平衡树](https://www.luogu.com.cn/problem/P3391)

```C++
#include <iostream>
#define endl "\n"
using namespace std;

const int N = 100010;

int n, m, root, idx;
struct node
{
	int s[2], v, p;
	int sz, rev;
	
	void init(int _v, int _p)
	{
		v = _v, p = _p;
		sz = 1;
	}
}tr[N];

void pushup(int u)
{
	tr[u].sz = tr[tr[u].s[0]].sz + tr[tr[u].s[1]].sz + 1;	
}

void pushdown(int u)
{
	if(tr[u].rev)
	{
		auto &l = tr[tr[u].s[0]], &r = tr[tr[u].s[1]];
		l.rev ^= 1, r.rev ^= 1;
		swap(l.s[0], l.s[1]), swap(r.s[0], r.s[1]);
		tr[u].rev = 0;
	}
}

void rotate(int x)
{
	int y = tr[x].p, z = tr[y].p;
	int k = tr[y].s[1] == x;
	tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;
	tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
	tr[x].s[k ^ 1] = y, tr[y].p = x;
	pushup(y), pushup(x);
}

void splay(int x, int k)
{
	while(tr[x].p != k)
	{
		int y = tr[x].p, z = tr[y].p;
		if(z != k)
			if((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
			else rotate(y);
		rotate(x);
	}
	if(!k) root = x;
}

void insert(int v)
{
	int u = root, p = 0;
	while(u) p = u, u = tr[u].s[v > tr[u].v];
	u = ++idx;
	if(p) tr[p].s[v > tr[p].v] = u;
	tr[u].init(v, p);
	splay(u, 0);
}

int get_k(int k)
{
	int u = root;
	while(u)
	{
		pushdown(u);
		if(tr[tr[u].s[0]].sz >= k) u = tr[u].s[0];
		else if(tr[tr[u].s[0]].sz + 1 == k) return u;
		else k -= tr[tr[u].s[0]].sz + 1, u = tr[u].s[1];
	}
	return -1;
}

void print(int u)
{
    pushdown(u);
	if(tr[u].s[0]) print(tr[u].s[0]);
	if(tr[u].v >= 1 && tr[u].v <= n) cout << tr[u].v << ' ';
	if(tr[u].s[1]) print(tr[u].s[1]);
}

int main()
{
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> n >> m;
	for(int i = 0; i <= n + 1; i++) insert(i);
	while(m--)
	{
		int l, r;
		cin >> l >> r;
		l = get_k(l), r = get_k(r + 2);
		splay(l, 0), splay(r, l);
		auto &son = tr[tr[r].s[0]];
		son.rev ^= 1;
		swap(son.s[0], son.s[1]);
		pushup(tr[r].s[0]);
	}
	print(root);
	return 0;
}
```
---
#### [洛谷P2042 [NOI2005] 维护数列——Splay的各种操作](https://www.luogu.com.cn/problem/P2042)

题意：插入一个区间、删除一个区间、推平一个区间、翻转一个区间、求区间和、求整个区间最大子段和。

```C++
#include <iostream>
#define endl "\n"
using namespace std;

const int N = 500010, INF = 0x3f3f3f3f;

int n, m, tt, root;
int a[N], nodes[N];
struct node
{
	int s[2], v, p, sz;
	int ms, ls, rs, sum;
	int same, rev;
	
	void init(int _v, int _p)
	{
		v = _v, p = _p, sz = 1;
		s[0] = s[1] = 0;
		ms = sum = v;
		ls = rs = max(v, 0);
		same = rev = 0;
	}
}tr[N];

void pushup(int u)
{
	auto &rt = tr[u], &l = tr[rt.s[0]], &r = tr[rt.s[1]];
	rt.sz = l.sz + 1 + r.sz;
	rt.sum = l.sum + rt.v + r.sum;
	rt.ls = max(l.ls, l.sum + rt.v + r.ls);
	rt.rs = max(r.rs, r.sum + rt.v + l.rs);
	rt.ms = max(max(l.ms, r.ms), l.rs + rt.v + r.ls);
}

void pushdown(int u)
{
	auto &rt = tr[u], &l = tr[rt.s[0]], &r = tr[rt.s[1]];
	if(rt.same)
	{
		if(rt.s[0]) l.same = 1, l.v = rt.v, l.sum = l.v * l.sz;
		if(rt.s[1]) r.same = 1, r.v = rt.v, r.sum = r.v * r.sz;
		if(rt.v > 0)
		{
			if(rt.s[0]) l.ms = l.ls = l.rs = l.sum;
			if(rt.s[1]) r.ms = r.ls = r.rs = r.sum;
		}
		else 
		{
			if(rt.s[0]) l.ms = l.v, l.ls = l.rs = 0;
			if(rt.s[1]) r.ms = r.v, r.ls = r.rs = 0;
		}
		rt.same = rt.rev = 0;
	}
	else if(rt.rev)
	{
		if(rt.s[0]) l.rev ^= 1, swap(l.ls, l.rs), swap(l.s[0], l.s[1]);
		if(rt.s[1]) r.rev ^= 1, swap(r.ls, r.rs), swap(r.s[0], r.s[1]);
		rt.rev = 0;
	}
}

void rotate(int x)
{
	int y = tr[x].p, z = tr[y].p;
	int k = tr[y].s[1] == x;
	tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;
	tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
	tr[x].s[k ^ 1] = y, tr[y].p = x;
	pushup(y), pushup(x);
}

int build(int l, int r, int p)
{
	int u = nodes[tt--];
	int mid = (l + r) >> 1;
	tr[u].init(a[mid], p);
	if(l < mid) tr[u].s[0] = build(l, mid - 1, u);
	if(r > mid) tr[u].s[1] = build(mid + 1, r, u);
	pushup(u);
	return u;
}

void splay(int x, int k)
{
	while(tr[x].p != k)
	{
		int y = tr[x].p, z = tr[y].p;
		if(z != k)
			if((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
			else rotate(y);
		rotate(x);
	}
	if(!k) root = x;
}

int get_k(int k)
{
	int u = root;
	while(u)
	{
		pushdown(u);
		if(tr[tr[u].s[0]].sz >= k) u = tr[u].s[0];
		else if(tr[tr[u].s[0]].sz + 1 == k) return u;
		else k -= tr[tr[u].s[0]].sz + 1, u = tr[u].s[1];
	}
	return -1;
}

void dfs(int u)
{
	if(tr[u].s[0]) dfs(tr[u].s[0]);
	if(tr[u].s[1]) dfs(tr[u].s[1]);
	nodes[++tt] = u;
}

void work(int &l, int &r)
{
	int pos, tol;
	cin >> pos >> tol;
	l = get_k(pos), r = get_k(pos + tol + 1);
	splay(l, 0), splay(r, l);
}

int main()
{
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	for(int i = 1; i < N; i++) nodes[++tt] = i;
	
	cin >> n >> m;
	tr[0].ms = a[0] = a[n + 1] = -INF;
	for(int i = 1; i <= n; i++) cin >> a[i];
	
	root = build(0, n + 1, 0);
	
	while(m--)
	{
		string s;
		cin >> s;
		if(s[0] == 'I')
		{
			int pos, tol;
			cin >> pos >> tol;
			for(int i = 0; i < tol; i++) cin >> a[i];
			
			int l = get_k(pos + 1), r = get_k(pos + 2);
			splay(l, 0), splay(r, l);
			tr[r].s[0] = build(0, tol - 1, r);
			pushup(r), pushup(l);
		}
		else if(s[0] == 'D')
		{
			int l, r;
			work(l, r);
			dfs(tr[r].s[0]);
			tr[r].s[0] = 0;
			pushup(r), pushup(l);
		}
		else if(s[0] == 'M' && s[2] == 'K')
		{
			int l, r, c;
			work(l, r);
			cin >> c;
			auto &son = tr[tr[r].s[0]];
			son.same = 1, son.v = c, son.sum = c * son.sz;
			if(c > 0) son.ms = son.ls = son.rs = son.sum;
			else son.ms = c, son.ls = son.rs = 0;
			pushup(r), pushup(l);
		}
		else if(s[0] == 'R')
		{
			int l, r;
			work(l, r);
			auto &son = tr[tr[r].s[0]];
			son.rev ^= 1;
			swap(son.ls, son.rs), swap(son.s[0], son.s[1]);
			pushup(r), pushup(l);
		}
		else if(s[0] == 'G')
		{
			int l, r;
			work(l, r);
			auto &son = tr[tr[r].s[0]];
			cout << son.sum << endl;
		}
		else cout << tr[root].ms << endl;
	}
	return 0;
}
```
---

#### [洛谷P3224 [HNOI2012]永无乡——启发式合并+平衡树](https://www.luogu.com.cn/problem/P3224)

题意：将两个点合并；查询与某个点在一个集合里第 $k$ 大的点的编号。

```C++
#include <iostream>
#define endl "\n"
using namespace std;

const int N = 100010;

int n, m, p[N], root[N];
struct node
{
	int s[2], v, p, id;
	int sz;
	
	void init(int _v, int _p, int _id)
	{
		v = _v, p = _p, id = _id;
		sz = 1;
	}
}tr[N];

void pushup(int u)
{
	tr[u].sz = tr[tr[u].s[0]].sz + tr[tr[u].s[1]].sz + 1;
}

void rotate(int x)
{
	int y = tr[x].p, z = tr[y].p;
	int k = tr[y].s[1] == x;
	tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;
	tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
	tr[x].s[k ^ 1] = y, tr[y].p = x;
	pushup(y), pushup(x);
}

void splay(int x, int k, int r)
{
	while(tr[x].p != k)
	{
		int y = tr[x].p, z = tr[y].p;
		if(z != k)
			if((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
			else rotate(y);
		rotate(x);
	}
	if(!k) root[r] = x;
}


void insert(int v, int id, int r)
{
	int u = root[r], p = 0;
	while(u) p = u, u = tr[u].s[v > tr[u].v];
	u = id;
	if(p) tr[p].s[v > tr[p].v] = u;
	tr[u].init(v, p, id);
	splay(u, 0, r);
}

int get_k(int k, int r)
{
	int u = root[r];
	while(u)
	{
		if(tr[tr[u].s[0]].sz >= k) u = tr[u].s[0];
		else if(tr[tr[u].s[0]].sz + 1 == k) return u;
		else k -= tr[tr[u].s[0]].sz + 1, u = tr[u].s[1];
	}
	return -1;
}

int find(int x)
{
	return p[x] = (p[x] != x ? find(p[x]) : x);
}

void dfs(int u, int r)
{
	if(tr[u].s[0]) dfs(tr[u].s[0], r);
	if(tr[u].s[1]) dfs(tr[u].s[1], r);
	insert(tr[u].v, tr[u].id, r);
}

void merge(int a, int b)
{
	a = find(a), b = find(b);
	if(a == b) return;
	if(tr[root[a]].sz > tr[root[b]].sz) swap(a, b);
	dfs(root[a], b);
	p[a] = b;
}

int main()
{
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> n >> m;
	for(int i = 1, v; i <= n; i++)
	{
		cin >> v;
		p[i] = root[i] = i;
		tr[i].init(v, 0, i);
	}
	
	while(m--)
	{
		int a, b;
		cin >> a >> b;
		merge(a, b);
	}
	
	cin >> m;
	while(m--)
	{
		int a, b;
		char op[2];
		cin >> op >> a >> b;
		if(*op == 'B') merge(a, b);
		else 
		{
			a = find(a);
			if(tr[root[a]].sz < b) cout << -1 <<  endl;
			else cout << get_k(b, a) << endl;
		}
	}
	return 0;
}
```
---

### 2.9 平衡树Treap

#### [P3369 【模板】普通平衡树](https://www.luogu.com.cn/problem/P3369)

```C++
#include <iostream>
#define endl "\n"
using namespace std;

const int N = 100010, INF = 0x3f3f3f3f;

int n, root, idx;
struct node
{
	int l, r;
	int key, val;
	int sz, cnt;
}tr[N];

void pushup(int u)
{
	tr[u].sz = tr[tr[u].l].sz + tr[tr[u].r].sz + tr[u].cnt;
}

void zig(int &p)
{
	int q = tr[p].l;
	tr[p].l = tr[q].r, tr[q].r = p, p = q;
	pushup(tr[p].r), pushup(p);
}

void zag(int &p)
{
	int q = tr[p].r;
	tr[p].r = tr[q].l, tr[q].l = p, p = q;
	pushup(tr[p].l), pushup(p);
}

int get_node(int key)
{
	int p = ++idx;
	tr[p].key = key;
	tr[p].cnt = tr[p].sz = 1;
	tr[p].val = rand();
	return p;
}

void build()
{
	get_node(-INF), get_node(INF);
	root = 1, tr[root].r = 2;
	pushup(root);
	
	if(tr[1].val < tr[2].val) zag(root);
}

void insert(int &p, int key)
{
	if(!p) p = get_node(key);
	else if(tr[p].key == key) tr[p].cnt++;
	else 
	{
		if(tr[p].key > key) 
		{
			insert(tr[p].l, key);
			if(tr[tr[p].l].val > tr[p].val) zig(p);
		}
		else 
		{
			insert(tr[p].r, key);
			if(tr[tr[p].r].val > tr[p].val) zag(p);
		}
	}
	pushup(p);
}

void remove(int &p, int key)
{
	if(!p) return;
	if(tr[p].key == key)
	{
		if(tr[p].cnt > 1) tr[p].cnt--;
		else if(tr[p].l || tr[p].r)
		{
			if(!tr[p].r || tr[tr[p].l].val > tr[tr[p].r].val)
			{
				zig(p);
				remove(tr[p].r, key);
			}
			else 
			{
				zag(p);
				remove(tr[p].l, key);
			}
		}
		else p = 0;
	}
	else if(tr[p].key > key) remove(tr[p].l, key);
	else remove(tr[p].r, key);
	pushup(p);
}

int get_rank_by_key(int p, int key)
{
	if(!p) return 0;
	
	if(tr[p].key == key) return tr[tr[p].l].sz + 1;
	else if(tr[p].key > key) return get_rank_by_key(tr[p].l, key);
	else return tr[tr[p].l].sz + tr[p].cnt + get_rank_by_key(tr[p].r, key);
}

int get_key_by_rank(int p, int rank)
{
	if(!p) return INF;
	if(tr[tr[p].l].sz >= rank) return get_key_by_rank(tr[p].l, rank);
	if(tr[tr[p].l].sz + tr[p].cnt >= rank) return tr[p].key;
	return get_key_by_rank(tr[p].r, rank - tr[tr[p].l].sz - tr[p].cnt);
}

int get_prev(int p, int key)
{
	if(!p) return -INF;
	if(tr[p].key >= key) return get_prev(tr[p].l, key);
	return max(tr[p].key, get_prev(tr[p].r, key));
}

int get_next(int p, int key)
{
	if(!p) return INF;
	if(tr[p].key <= key) return get_next(tr[p].r, key);
	return min(tr[p].key, get_next(tr[p].l, key));
}

int main()
{
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	build();
	
	cin >> n;
	while(n--)
	{
		int op, x;
		cin >> op >> x;
		if(op == 1) insert(root, x);
		else if(op == 2) remove(root, x);
		else if(op == 3) cout << get_rank_by_key(root, x) - 1 << endl;
		else if(op == 4) cout << get_key_by_rank(root, x + 1) << endl;
		else if(op == 5) cout << get_prev(root, x) << endl;
		else cout << get_next(root, x) << endl;
	}
	return 0;
}
```
---


### 2.10 树套树

#### [洛谷P3332 [ZJOI2013]K大数查询——线段树套线段树](https://www.luogu.com.cn/problem/P3332)

```C++
#include <iostream>
#include <algorithm>
#include <vector>
#define endl "\n"
using namespace std;

typedef long long LL;
const int N = 50010, M = N * 4, K = N * 18 * 18;

int n, m, idx;
struct que
{
	int op, a, b;
	LL c;
}q[N];
struct node
{
	int l, r;
	LL sum, add;
}tr[K];
int lson[M], rson[M], t[M];
vector<int> v;

void init()
{
	sort(v.begin(), v.end());
	v.erase(unique(v.begin(), v.end()), v.end());
}

int find(int x)
{
	return lower_bound(v.begin(), v.end(), x) - v.begin();
}

void build(int u, int l, int r)
{
	lson[u] = l, rson[u] = r, t[u] = ++idx;
	if(l == r) return;
	int mid = (l + r) >> 1;
	build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
}

int intersection(int a, int b, int c, int d)
{
	return min(b, d) - max(a, c) + 1;
}

void update(int u, int l, int r, int a, int b)
{
	tr[u].sum += intersection(l, r, a, b);
	if(a <= l && r <= b) 
	{
		tr[u].add++;
		return;
	}
	int mid = (l + r) >> 1;
	if(a <= mid)
	{
		if(!tr[u].l) tr[u].l = ++idx;
		update(tr[u].l, l, mid, a, b);
	}
	if(b > mid)
	{
		if(!tr[u].r) tr[u].r = ++idx;
		update(tr[u].r, mid + 1, r, a, b);
	}
}

void change(int u, int a, int b, int x)
{
	update(t[u], 1, n, a, b);
	if(lson[u] == rson[u]) return;
	int mid = (lson[u] + rson[u]) >> 1;
	if(x <= mid) change(u << 1, a, b, x);
	else change(u << 1 | 1, a, b, x);
}

LL get_sum(int u, int l, int r, int a, int b, LL add)
{
	if(a <= l && r <= b) return tr[u].sum + ((LL)r - l + 1) * add;
	int mid = (l + r) >> 1;
	LL res = 0;
	add += tr[u].add;
	if(a <= mid)
	{
		if(!tr[u].l) res += add * intersection(l, mid, a, b);
		else res += get_sum(tr[u].l, l, mid, a, b, add);
	}
	if(b > mid)
	{
		if(!tr[u].r) res += add * intersection(mid + 1, r, a, b);
		else res += get_sum(tr[u].r, mid + 1, r, a, b, add);
	}
	return res;
}

int query(int u, int a, int b, LL c)
{
	if(lson[u] == rson[u]) return lson[u];
	int mid = (lson[u] + rson[u]) >> 1;
	LL res = get_sum(t[u << 1 | 1], 1, n, a, b, 0);
	if(res >= c) return query(u << 1 | 1, a, b, c);
	else return query(u << 1, a, b, c - res);
}

int main()
{
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> n >> m;
	for(int i = 0; i < m; i++)
	{
		cin >> q[i].op >> q[i].a >> q[i].b >> q[i].c;
		if(q[i].op == 1) v.push_back(q[i].c);
	}
	init();
	build(1, 0, v.size() - 1);
	for(int i = 0; i < m; i++)
	{
		int op = q[i].op, a = q[i].a, b = q[i].b;
		LL c = q[i].c;
		if(op == 1) change(1, a, b, find(c));
		else cout << v[query(1, a, b, c)] << endl;
	}
	return 0;
}
```
---

#### [洛谷P3380 【模板】二逼平衡树（树套树）——线段树套平衡树](https://www.luogu.com.cn/problem/P3380)
```C++
#include <iostream>
#define endl "\n"
using namespace std;

const int N = 50010, M = N * 4, K = M * 20;
const int INF = 2147483647;

int n, m, a[N];
struct node
{
	int s[2], v, p, cnt, sz;
	
	void init(int _v, int _p)
	{
		v = _v, p = _p, sz = cnt = 1;
	}
}tr[K];
int lson[M], rson[M], t[M], idx;

void pushup(int u)
{
	tr[u].sz = tr[tr[u].s[0]].sz + tr[tr[u].s[1]].sz + tr[u].cnt;
}

void rotate(int x)
{
	int y = tr[x].p, z = tr[y].p;
	int k = tr[y].s[1] == x;
	tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;
	tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
	tr[x].s[k ^ 1] = y, tr[y].p = x;
	pushup(y), pushup(x);
}

void splay(int &root, int x, int k)
{
	while(tr[x].p != k)
	{
		int y = tr[x].p, z = tr[y].p;
		if(z != k)
			if((tr[y].s[1] == x) ^ (tr[z].s[1] == y)) rotate(x);
			else rotate(y);
		rotate(x);
	}
	if(!k) root = x;
}

void insert(int &root, int v)
{
	int u = root, p = 0, flag = 0;
	while(u)
	{
		int tv = tr[u].v;
		if(tv == v) 
		{
			flag = 1;
			break;
		}
		p = u, u = tr[u].s[v > tv];
	}
	if(flag) tr[u].cnt++;
	else 
	{
		u = ++idx;
		if(p) tr[p].s[v > tr[p].v] = u;
		tr[u].init(v, p);
	}
	splay(root, u, 0);
}

void update(int &root, int v, int y)
{
	int u = root;
	while(u)
	{
		if(tr[u].v == v) break;
		else if(tr[u].v > v) u = tr[u].s[0];
		else u = tr[u].s[1];
	}
	splay(root, u, 0);
	int l = tr[u].s[0], r = tr[u].s[1];
	while(tr[l].s[1]) l = tr[l].s[1];
	while(tr[r].s[0]) r = tr[r].s[0];
	splay(root, l, 0), splay(root, r, l);
	auto &son = tr[tr[r].s[0]];
	if(son.cnt > 1) son.cnt--, pushup(tr[r].s[0]);
	else tr[r].s[0] = 0;
	pushup(r), pushup(l);
	insert(root, y);
}

int get_cnt(int &root, int v)
{
	int res = 0, u = root;
	while(u)
	{
		if(tr[u].v < v) res += tr[tr[u].s[0]].sz + tr[u].cnt, u = tr[u].s[1];
		else u = tr[u].s[0];
	}
	return res;
}

int get_pre(int &root, int v)
{
	int res = -INF, u = root;
	while(u)
	{
		if(tr[u].v < v) res = max(res, tr[u].v), u = tr[u].s[1];
		else u = tr[u].s[0];
	}
	return res;
}

int get_suc(int &root, int v)
{
	int res = INF, u = root;
	while(u)
	{
		if(tr[u].v > v) res = min(res, tr[u].v), u = tr[u].s[0];
		else u = tr[u].s[1];
	}
	return res;
}

void build(int u, int l, int r)
{
	insert(t[u], -INF), insert(t[u], INF);
	lson[u] = l, rson[u] = r;
	for(int i = l; i <= r; i++) insert(t[u], a[i]);
	if(l == r) return;
	int mid = (l + r) >> 1;
	build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
}

void change(int u, int x, int v)
{
	update(t[u], a[x], v);
	if(lson[u] == rson[u]) return;
	int mid = (lson[u] + rson[u]) >> 1;
	if(x <= mid) change(u << 1, x, v);
	else change(u << 1 | 1, x, v);
}

int query_rank(int u, int l, int r, int v)
{
	if(l <= lson[u] && rson[u] <= r) return get_cnt(t[u], v) - 1;
	int mid = (lson[u] + rson[u]) >> 1, res = 0;
	if(l <= mid) res += query_rank(u << 1, l, r, v);
	if(r > mid) res += query_rank(u << 1 | 1, l, r, v);
	return res;
}

int query_key(int u, int l, int r, int rank)
{
	int a = 0, b = 1e8;
	while(a < b)
	{
		int mid = (a + b + 1) >> 1;
		if(query_rank(u, l, r, mid) + 1 <= rank) a = mid;
		else b = mid - 1;
	}	
	return a;
}

int query_pre(int u, int l, int r, int v)
{
	if(l <= lson[u] && rson[u] <= r) return get_pre(t[u], v);
	int mid = (lson[u] + rson[u]) >> 1, res = -INF;
	if(l <= mid) res = max(res, query_pre(u << 1, l, r, v));
	if(r > mid) res = max(res, query_pre(u << 1 | 1, l, r, v));
	return res;
}

int query_suc(int u, int l, int r, int v)
{
	if(l <= lson[u] && rson[u] <= r) return get_suc(t[u], v);
	int mid = (lson[u] + rson[u]) >> 1, res = INF;
	if(l <= mid) res = min(res, query_suc(u << 1, l, r, v));
	if(r > mid) res = min(res, query_suc(u << 1 | 1, l, r, v));
	return res;
}

int main()
{
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> n >> m;
	for(int i = 1; i <= n; i++) cin >> a[i];
	build(1, 1, n);
	while(m--)
	{
		int op, l, r, x;
		cin >> op >> l >> r;
		if(op == 1) cin >> x, cout << query_rank(1, l, r, x) + 1 << endl;
		else if(op == 2) cin >> x, cout << query_key(1, l, r, x) << endl;
		else if(op == 3) change(1, l, r), a[l] = r;
		else if(op == 4) cin >> x, cout << query_pre(1, l, r, x) << endl;
		else cin >> x, cout << query_suc(1, l, r, x) << endl;
	}
	return 0;
}
```
---

### 2.11 树链剖分

#### [洛谷P1505 [国家集训队]旅游——树链剖分](https://www.luogu.com.cn/problem/P1505)
维护五个操作：修改一条边权、将 $u$、$v$ 之间的边权变成相反数、询问 $u、v$ 之间的边权和、最大值、最小值。

```C++
#include <iostream>
#define endl "\n"
using namespace std;

const int N = 200010, M = N * 2;
const int INF = 0x3f3f3f3f;

int n, m;
int h[N], e[M], ne[M], w[M], idx;
int id[N], nw[N], fa[N], top[N], cnt;
int sz[N], son[N], a[N];
struct edge
{
	int u, v;
}eg[N];
struct node
{
	int l, r;
	bool flag;
	int sum, mx, mi;
}tr[N * 4];

void add(int a, int b, int c)
{
	e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx++;		
}

void dfs1(int u, int father)
{
	sz[u] = 1, fa[u] = father;
	for(int i = h[u]; i != -1; i = ne[i])
	{
		int j = e[i];
		if(j == father) continue;
		a[j] += w[i];
		
		dfs1(j, u);
		sz[u] += sz[j];
		if(sz[son[u]] < sz[j]) son[u] = j;
	}
}

void dfs2(int u, int t)
{
	id[u] = ++cnt, nw[cnt] = a[u], top[u] = t;
	
	if(!son[u]) return;
	dfs2(son[u], t);
	for(int i = h[u]; i != -1; i = ne[i])
	{
		int j = e[i];
		if(j == fa[u] || j == son[u]) continue;
		dfs2(j, j);
	}
}

void pushup(int u)
{
	tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;
	tr[u].mx = max(tr[u << 1].mx, tr[u << 1 | 1].mx);
	tr[u].mi = min(tr[u << 1].mi, tr[u << 1 | 1].mi);
}

void turn(node &r)
{
	r.sum = -r.sum;
	r.mx = -r.mx;
	r.mi = -r.mi;
	swap(r.mx, r.mi);
	r.flag = !r.flag;
}

void pushdown(int u)
{
	if(tr[u].flag)
	{
		turn(tr[u << 1]), turn(tr[u << 1 | 1]);
		tr[u].flag = false;
	}
}

void build(int u, int l, int r)
{
	if(l == r)
	{
		tr[u] = {l, r, false, nw[r], nw[r], nw[r]};
		return;
	}
	tr[u].l = l, tr[u].r = r, tr[u].flag = false;
	int mid = (l + r) >> 1;
	build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
	pushup(u);
}

void update(int u, int x, int v)
{
	if(tr[u].l == x && tr[u].r == x)
	{
		tr[u].sum = tr[u].mx = tr[u].mi = v;
		tr[u].flag = false;
		return;
	}
	pushdown(u);
	int mid = (tr[u].l + tr[u].r) >> 1;
	if(x <= mid) update(u << 1, x, v);
	else update(u << 1 | 1, x, v);
	pushup(u);
}

void change(int u, int l, int r)
{
	if(l <= tr[u].l && tr[u].r <= r)
	{
		turn(tr[u]);
		return;
	}
	pushdown(u);
	int mid = (tr[u].l + tr[u].r) >> 1;
	if(l <= mid) change(u << 1, l, r);
	if(r > mid) change(u << 1 | 1, l, r);
	pushup(u);
}

int query_sum(int u, int l, int r)
{
	if(l <= tr[u].l && tr[u].r <= r) return tr[u].sum;
	pushdown(u);
	int mid = (tr[u].l + tr[u].r) >> 1;
	int res = 0;
	if(l <= mid) res += query_sum(u << 1, l, r);
	if(r > mid) res += query_sum(u << 1 | 1, l, r);
	return res;		
}

int query_mx(int u, int l, int r)
{
	if(l <= tr[u].l && tr[u].r <= r) return tr[u].mx;
	pushdown(u);
	int mid = (tr[u].l + tr[u].r) >> 1;
	int res = -INF;
	if(l <= mid) res = max(res, query_mx(u << 1, l, r));
	if(r > mid) res = max(res, query_mx(u << 1 | 1, l, r));
	return res;		
}

int query_mi(int u, int l, int r)
{
	if(l <= tr[u].l && tr[u].r <= r) return tr[u].mi;
	pushdown(u);
	int mid = (tr[u].l + tr[u].r) >> 1;
	int res = INF;
	if(l <= mid) res = min(res, query_mi(u << 1, l, r));
	if(r > mid) res = min(res, query_mi(u << 1 | 1, l, r));		
	return res;
}

void update_path(int u, int v)
{
	while(top[u] != top[v])
	{
		if(id[top[u]] < id[top[v]]) swap(u, v);
		change(1, id[top[u]], id[u]);
		u = fa[top[u]];
	}
	if(id[u] < id[v]) swap(u, v);
	change(1, id[v] + 1, id[u]);
}

int query_path(int u, int v, int op)
{
	int res;
	if(op == 1) res = 0;
	else if(op == 2) res = -INF;
	else res = INF;
	while(top[u] != top[v])
	{
		if(id[top[u]] < id[top[v]]) swap(u, v);
		if(op == 1) res += query_sum(1, id[top[u]], id[u]);
		else if(op == 2) res = max(res, query_mx(1, id[top[u]], id[u]));
		else res = min(res, query_mi(1, id[top[u]], id[u]));
		u = fa[top[u]];
	}
	if(id[u] < id[v]) swap(u, v);
	if(op == 1) res += query_sum(1, id[v] + 1, id[u]);
	else if(op == 2) res = max(res, query_mx(1, id[v] + 1, id[u]));
	else res = min(res, query_mi(1, id[v] + 1, id[u]));
	return res;
}

int main()
{
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> n;
	for(int i = 1; i <= n; i++) h[i] = -1;
	for(int i = 1; i <= n - 1; i++)
	{
		int a, b, c;
		cin >> a >> b >> c;
		a++, b++;
		add(a, b, c), add(b, a, c);
		eg[i] = {a, b}; 
	}
	
	dfs1(1, -1);
	dfs2(1, 1);
	
	build(1, 1, n);
	
	cin >> m;
	while(m--)
	{
		string s;
		int x, y;
		cin >> s >> x >> y;
		if(s[0] == 'C') 
		{
			int u = eg[x].u, v = eg[x].v;
			if(fa[v] == u) u = v;
			update(1, id[u], y);
			continue;
		}
		x++, y++;
		if(s[0] == 'N') update_path(x, y);
		else if(s[0] == 'S') cout << query_path(x, y, 1) << endl;
		else if(s[1] == 'A') cout << query_path(x, y, 2) << endl;
		else cout << query_path(x, y, 3) << endl;
	}
	return 0;
}
```
---

#### [洛谷P4315. 月下“毛景树”——树链剖分、线段树区间推平（赋值）、区间加、区间最值](https://www.luogu.com.cn/problem/P4315)

这道题综合了 [P4114](https://www.luogu.com.cn/problem/P4114)、[P1253](https://www.luogu.com.cn/problem/P1253) 的边权下方子节点的技巧以及区间推平等线段树知识，这里就不多赘述。

```C++
#include <iostream>
#define endl "\n"
using namespace std;

const int N = 100010, M = N * 2;
typedef long long LL;
const LL INF = 1e18;

int n, cnt;
int d[N], fa[N], son[N], sz[N], top[N];
int h[N], e[M], ne[M], idx, id[N], nw[N];
int w[N], wei[M];
struct edge
{
	int u, v;
}eg[N];
struct node
{
	int l, r;
	LL add, assg, mx;
}tr[N * 4];

void add(int a, int b, int c)
{
	e[idx] = b, ne[idx] = h[a], wei[idx] = c, h[a] = idx++;	
}

void dfs1(int u, int father, int dep)
{
	sz[u] = 1, fa[u] = father, d[u] = dep;
	for(int i = h[u]; i != -1; i = ne[i])
	{
		int j = e[i];
		if(j == father) continue;
		w[j] = wei[i];
		dfs1(j, u, dep + 1);
		sz[u] += sz[j];
		if(sz[son[u]] < sz[j]) son[u] = j;
	}
}

void dfs2(int u, int t)
{
	top[u] = t, id[u] = ++cnt, nw[cnt] = w[u];
	if(!son[u]) return;
	dfs2(son[u], t);
	for(int i = h[u]; i != -1; i = ne[i])
	{
		int j = e[i];
		if(j == fa[u] || j == son[u]) continue;
		dfs2(j, j);
	}
}

void pushup(int u)
{
	tr[u].mx = max(tr[u << 1].mx, tr[u << 1 | 1].mx);
}

void pushdown(int u)
{
	auto &root = tr[u], &le = tr[u << 1], &ri = tr[u << 1 | 1];
	if(root.assg != INF)
	{
		le.add = ri.add = 0;
		le.assg = ri.assg = root.assg;
		le.mx = ri.mx = root.assg;
		root.assg = INF;
	}
	if(root.add)
	{
		le.add += root.add, le.mx += root.add;
		ri.add += root.add, ri.mx += root.add;
		root.add = 0;
	}
}

void build(int u, int l, int r)
{
	tr[u] = {l, r, 0, INF, nw[r]};
	if(l == r) return;
	int mid = (l + r) >> 1;
	build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
	pushup(u);
}

void update(int u, int l, int r, LL k, bool add)
{
	if(l <= tr[u].l && tr[u].r <= r)
	{
		if(add) tr[u].add += k, tr[u].mx += k;
		else tr[u].assg = tr[u].mx = k, tr[u].add = 0;
		return;
	}
	pushdown(u);
	int mid = (tr[u].l + tr[u].r) >> 1;
	if(l <= mid) update(u << 1, l, r, k, add);
	if(r > mid) update(u << 1 | 1, l, r, k, add);
	pushup(u);
}

LL query(int u, int l, int r)
{
	if(l <= tr[u].l && tr[u].r <= r) return tr[u].mx;
	pushdown(u);
	int mid = (tr[u].l + tr[u].r) >> 1;
	LL res = 0;
	if(l <= mid) res = max(query(u << 1, l, r), res);
	if(r > mid) res = max(query(u << 1 | 1, l, r), res);
	return res;
}

void update_node(int u, int w)
{
	update(1, id[u], id[u], w, false);
}

void update_path(int u, int v, int k, bool flag)
{
	while(top[u] != top[v])
	{
		if(d[top[u]] < d[top[v]]) swap(u, v);
		update(1, id[top[u]], id[u], k, flag);
		u = fa[top[u]];
	}
	if(d[u] < d[v]) swap(u, v);
	update(1, id[v] + 1, id[u], k, flag);
}

LL query_path(int u, int v)
{
	LL res = 0;
	while(top[u] != top[v])
	{
		if(d[top[u]] < d[top[v]]) swap(u, v);
		res = max(query(1, id[top[u]], id[u]), res);
		u = fa[top[u]];
	}
	if(d[u] < d[v]) swap(u, v);
	res = max(query(1, id[v] + 1, id[u]), res);
	return res;
}
int main()
{
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> n;
	for(int i = 1; i <= n; i++) h[i] = -1;
	for(int i = 1; i <= n - 1; i++)
	{
		int a, b, c;
		cin >> a >> b >> c;
		add(a, b, c), add(b, a, c);
		eg[i] = {a, b};
	}
	
	dfs1(1, -1, 1);
	dfs2(1, 1);
	build(1, 1, n);
	
	string op;
	while(cin >> op, op[0] != 'S')
	{
		int u, v, w;
		cin >> u >> v;	
		if(op[0] == 'A')
		{
			cin >> w;
			update_path(u, v, w, true);
		}
		else if(op[1] == 'o') 
		{
			cin >> w;	
			update_path(u, v, w, false);
		}
		else if(op[0] == 'C')
		{
			if(fa[eg[u].v] == eg[u].u) u = eg[u].v;
			else u = eg[u].u;
			
			update_node(u, v);
		}
		else cout << query_path(u, v) << endl;
	}
	return 0;
}
```
---


### 2.12 分块
#### 区间加、区间求和
```C++
#include <iostream>
#include <cmath>
#define endl "\n"
using namespace std;

const int N = 100010, M = 410;
typedef long long LL;

int n, m, len, pos[N];
LL w[N], sum[N], add[N];

void update(int l, int r, int x)
{
    if(pos[l] == pos[r])
    {
        for(int i = l; i <= r; i++) w[i] += x, sum[pos[i]] += x;
    }
    else 
    {
        int i = l, j = r;
        while(pos[i] == pos[l]) w[i] += x, sum[pos[i]] += x, i++;
        while(pos[j] == pos[r]) w[j] += x, sum[pos[j]] += x, j--;
        for(int k = pos[i]; k <= pos[j]; k++) add[k] += x, sum[k] += len * x;
    }
}

LL query(int l, int r)
{
    LL res = 0;
    if(pos[l] == pos[r])
    {
        for(int i = l; i <= r; i++) res += w[i] + add[pos[i]];
    }
    else 
    {
        int i = l, j = r;
        while(pos[i] == pos[l]) res += w[i] + add[pos[i]], i++;
        while(pos[j] == pos[r]) res += w[j] + add[pos[j]], j--;
        for(int k = pos[i]; k <= pos[j]; k++) res += sum[k];
    }
    return res;
}
int main()
{
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    cin >> n >> m;
    len = sqrt(n);
    for(int i = 1; i <= n; i++) pos[i] = i / len;
    for(int i = 1; i <= n; i++) cin >> w[i], sum[pos[i]] += w[i];
    while(m--)
    {
        int l, r, k, op;
        cin >> op >> l >> r;
        if(op - 1) cout << query(l, r) << endl;
        else cin >> k, update(l, r, k);
    }
    return 0;
}
```
---

### 2.13 莫队

#### [Acwing2492. HH的项链——基础莫队](https://www.acwing.com/problem/content/2494/)
题意：求区间不同数的数量。
```C++
#include <iostream>
#include <algorithm>
#include <cmath>
#define endl "\n"
using namespace std;

const int N = 50010, M = 200010;
const int K = 1000010;

int n, m, len;
int pos[N], a[N], ans[M], cnt[K];
struct query
{
    int id, l, r;
}q[M];

bool cmp(query &a, query &b)
{
    int p1 = pos[a.l], p2 = pos[b.l];
    if(p1 != p2) return p1 < p2;
    return (p1 % 2 ? a.r < b.r : a.r > b.r);
}

void add(int x, int &res)
{
    cnt[x]++;
    if(cnt[x] == 1) res++;
}

void del(int x, int &res)
{
    cnt[x]--;
    if(cnt[x] == 0) res--;
}

int main()
{
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    cin >> n;
    len = sqrt(n);
    for(int i = 1; i <= n; i++) pos[i] = i / len;
    for(int i = 1; i <= n; i++) cin >> a[i];
    cin >> m;
    for(int i = 1; i <= m; i++)
    {
        int l, r;
        cin >> l >> r;
        q[i] = {i, l, r};
    }
    
    sort(q + 1, q + 1 + m, cmp);
    
    for(int i = 0, j = 1, k = 1, res = 0; k <= m; k++)
    {
        int id = q[k].id, l = q[k].l, r = q[k].r;
        while(i < r) add(a[++i], res);
        while(i > r) del(a[i--], res);
        
        while(j < l) del(a[j++], res);
        while(j > l) add(a[--j], res);
        
        ans[id] = res;
    }
    
    for(int i = 1; i <= m; i++) cout << ans[i] << endl;
    return 0;
}
```
---
#### # [洛谷P1903 [国家集训队] 数颜色 / 维护队列——带修莫队](https://www.luogu.com.cn/problem/P1903)
**代码**
```C++
#include <iostream>
#include <cmath>
#include <algorithm>
#define endl "\n"
using namespace std;

const int N = 150010, M = 1000010;

int n, m, mq, mt, len;
int a[N], pos[N], cnt[M], ans[N];
struct query
{
	int id, l, r, t;
	bool operator < (const query & x) const 
	{
		if(pos[l] ^ pos[x.l]) return pos[l] < pos[x.l];
		if(pos[r] ^ pos[x.r]) return pos[r] < pos[x.r];
		return t < x.t;
	}
}q[N];
struct modify
{
	int u, v;
}c[N];

void init()
{
    // if(!mt) len = sqrt(n);
	// else len = cbrt((double)n * mt) + 1;
	len = cbrt((double)n * max(1, mt)) + 1;
	for(int i = 1; i <= n; i++) pos[i] = (i - 1) / len + 1;
	
	sort(q + 1, q + 1 + mq);
}

void add(int x, int &res)
{
	if(!cnt[x]) res++;
	cnt[x]++;
}

void del(int x, int &res)
{
	cnt[x]--;
	if(!cnt[x]) res--;
}

int main()
{
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> n >> m;
	for(int i = 1; i <= n; i++) cin >> a[i];
	for(int i = 1; i <= m; i++)
	{
		char op[2];
		int l, r;
		cin >> op >> l >> r;
		if(*op == 'Q') mq++, q[mq] = {mq, l, r, mt};
		else c[++mt] = {l, r};
	}
	init();
	for(int i = 0, j = 1, t = 0, res = 0, k = 1; k <= mq; k++)
	{
		int id = q[k].id, l = q[k].l, r = q[k].r, qt = q[k].t;
		while(i < r) add(a[++i], res);
		while(i > r) del(a[i--], res);
		while(j < l) del(a[j++], res);
		while(j > l) add(a[--j], res);
		while(t < qt)
		{
			t++;
			if(c[t].u >= l && c[t].u <= r)
			{
				del(a[c[t].u], res);
				add(c[t].v, res);
			}
			swap(a[c[t].u], c[t].v);
		}
		while(t > qt)
		{
			if(c[t].u >= l && c[t].u <= r)
			{
				del(a[c[t].u], res);
				add(c[t].v, res);
			}
			swap(a[c[t].u], c[t].v);
			t--;
		}
		ans[id] = res;
	}
	for(int i = 1; i <= mq; i++) cout << ans[i] << endl;
	return 0;
}
```
---
#### [洛谷P5906 【模板】回滚莫队&不删除莫队](https://www.luogu.com.cn/problem/P5906)
题意：求区间中相同的数的最远距离。
```C++
#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstring>
#define endl "\n"
using namespace std;

const int N = 200010, INF = 0x3f3f3f3f;

int n, m, len, tol;
int a[N], b[N], pos[N];
int minl[N], maxr[N], ans[N];
int bmi[N], bmx[N];
struct query
{
	int id, l, r;
	bool operator < (const query & x) const 
	{
		return pos[l] ^ pos[x.l] ? pos[l] < pos[x.l] : r < x.r;
	}
}q[N];

void init()
{
	len = sqrt(n);
	for(int i = 1; i <= n; i++) pos[i] = (i - 1) / len + 1;
	tol = pos[n];
	
	sort(b + 1, b + 1 + n);
	int k = unique(b + 1, b + 1 + n) - b - 1;
	for(int i = 1; i <= n; i++)
		a[i] = lower_bound(b + 1, b + 1 + k, a[i]) - b;
	sort(q + 1, q + 1 + m);
}

int calc(int l, int r)
{
	int res = 0, mi[N], mx[N];
	for(int i = l; i <= r; i++) mi[a[i]] = INF, mx[a[i]] = 0;
	for(int i = l; i <= r; i++)
	{
		mi[a[i]] = min(mi[a[i]], i);
		mx[a[i]] = max(mx[a[i]], i);
		res = max(res, mx[a[i]] - mi[a[i]]);
	}
	return res;
}
int main()
{
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> n;
	for(int i = 1; i <= n; i++) cin >> a[i], b[i] = a[i];
	cin >> m;
	for(int i = 1; i <= m; i++)
	{
		int l, r;
		cin >> l >> r;
		q[i] = {i, l, r};
	}
	init();
	for(int x = 1, y = 1; x <= tol; x++)
	{
		int right = min(n, x * len), i = right, j = right + 1;
		memset(minl, 0x3f, sizeof minl), memset(maxr, 0, sizeof maxr);
		memset(bmi, 0x3f, sizeof bmi), memset(bmx, 0, sizeof bmx);
		int res = 0, backup;
		for(; pos[q[y].l] == x; y++)
		{
			if(pos[q[y].r] == x)
			{
				ans[q[y].id] = calc(q[y].l, q[y].r);
				continue;
			}
			
			int id = q[y].id, l = q[y].l, r = q[y].r;
			while(i < r)
			{
				int x = a[++i];
				minl[x] = min(minl[x], i);
				maxr[x] = max(maxr[x], i);
				res = max(res, maxr[x] - minl[x]);
				bmi[x] = minl[x], bmx[x] = maxr[x];
			}
			backup = res;
			while(j > l)
			{
				int x = a[--j];
				minl[x] = min(minl[x], j);
				maxr[x] = max(maxr[x], j);
				res = max(res, maxr[x] - minl[x]);
			}
			while(j < right + 1) minl[a[j]] = bmi[a[j]], maxr[a[j]] = bmx[a[j]], j++;
			ans[id] = res;
			res = backup;
		}
	}
	for(int i = 1; i <= m; i++) cout << ans[i] << endl;
	return 0;
}
```
---
#### [Closest Equals——回滚莫队](https://www.luogu.com.cn/problem/CF522D)
题意：求两个相同的数的最近距离。
```C++
#include <iostream>
#include <cmath>
#include <cstring>
#include <algorithm>
#define endl "\n"
using namespace std;

const int N = 500010, INF = 0x3f3f3f3f;

int n, m, len, tol, a[N], b[N], pos[N];
int pr[N], pl[N], ans[N], minr[N];
struct query
{
	int id, l, r;
	bool operator < (const query &x) const 
	{
		return pos[l] ^ pos[x.l] ? pos[l] < pos[x.l] : r < x.r;
	}
}q[N];

void init()
{
	len = sqrt(n);
	for(int i = 1; i <= n; i++) pos[i] = (i - 1) / len + 1;
	tol = pos[n];
	
	sort(b + 1, b + 1 + n);
	int k = unique(b + 1, b + 1 + n) - b - 1;
	for(int i = 1; i <= n; i++)
		a[i] = lower_bound(b + 1, b + 1 + k, a[i]) - b;
	sort(q + 1, q + 1 + m);
}

int calc(int l, int r)
{
	int res = INF, cnt[N];
	for(int i = l; i <= r; i++) cnt[a[i]] = 0;
	for(int i = l; i <= r; i++)
	{
		if(!cnt[a[i]]) cnt[a[i]] = i;
		else res = min(res, i - cnt[a[i]]), cnt[a[i]] = i;
	}
	return (res ^ INF ? res : -1);
}
int main()
{
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> n >> m;
	for(int i = 1; i <= n; i++) cin >> a[i], b[i] = a[i];
	for(int i = 1; i <= m; i++)
	{
		int l, r;
		cin >> l >> r;
		q[i] = {i, l, r};
	}
	init();
	for(int x = 1, y = 1; x <= tol; x++)
	{
		int right = min(n, x * len), i = right, j = right + 1, res = INF;
		memset(minr, 0, sizeof minr);
		memset(pl, 0, sizeof pl), memset(pr, 0, sizeof pr);
		for(; pos[q[y].l] == x; y++)
		{
			if(pos[q[y].r] == x)
			{
				ans[q[y].id] = calc(q[y].l, q[y].r);
				continue;
			}
			
			int id = q[y].id, l = q[y].l, r = q[y].r, backup;
			while(i < r)
			{
				i++;
				if(!minr[a[i]]) minr[a[i]] = i;
				else res = min(res, i - pr[a[i]]);
				pr[a[i]] = i;
			}
			backup = res;
			while(j > l)
			{
				j--;
				if(!pl[a[j]])
				{
					if(minr[a[j]]) res = min(res, minr[a[j]] - j);
				}
				else res = min(res, pl[a[j]] - j);
				pl[a[j]] = j;
			}
			while(j < right + 1)
			{
				pl[a[j]] = 0;
				j++;
			}
			ans[id] = (res ^ INF ? res : -1);
			res = backup;
		}
	}
	for(int i = 1; i <= m; i++) cout << ans[i] << endl;
	return 0;
}
```
---

### 2.14 哈希表

#### [拉链法模拟哈希表](https://www.acwing.com/problem/content/842/)
```C++
#include <bits/stdc++.h>
using namespace std;

const int N = 100003;

int n;
int h[N], e[N], ne[N], idx;

void insert(int x) {
    int k = (x % N + N) % N;
    e[idx] = x, ne[idx] = h[k], h[k] = idx++;
}

bool find(int x) {
    int k = (x % N + N) % N;
    for(int i = h[k]; i != -1; i = ne[i]) {
        if(e[i] == x)
            return true;
    }
    return false;
}

int main() {
    memset(h, -1, sizeof(h));
    scanf("%d", &n);
    
    while(n--) {
        char op[2];
        int x;
        scanf("%s%d", op, &x);
        if(*op == 'I') {
            insert(x);
        }
        else {
            if(find(x)) puts("Yes");
            else puts("No");
        }
    }
    return 0;
}
```
---
#### [开放寻址法模拟散列表](https://www.acwing.com/problem/content/842/)
```C++
#include <bits/stdc++.h>
using namespace std;

const int N = 100003;

int n;
int h[N], e[N], ne[N], idx;

void insert(int x) {
    int k = (x % N + N) % N;
    e[idx] = x, ne[idx] = h[k], h[k] = idx++;
}

bool find(int x) {
    int k = (x % N + N) % N;
    for(int i = h[k]; i != -1; i = ne[i]) {
        if(e[i] == x)
            return true;
    }
    return false;
}

int main() {
    memset(h, -1, sizeof(h));
    scanf("%d", &n);
    
    while(n--) {
        char op[2];
        int x;
        scanf("%s%d", op, &x);
        if(*op == 'I') {
            insert(x);
        }
        else {
            if(find(x)) puts("Yes");
            else puts("No");
        }
    }
    return 0;
}
```

### 2.15 堆
#### [数组模拟堆](https://www.acwing.com/problem/content/841/)
```C++
#include <bits/stdc++.h>
using namespace std;

const int N = 100010;

//ph[i] 第i个插入的数对应的堆数组中的下标
//hp[i] 堆数组中下标为i对应第几个插入的数 
int h[N], ph[N], hp[N], cnt;

void heap_swap(int a, int b) {
    swap(h[a], h[b]);
    swap(ph[hp[a]], ph[hp[b]]);
    swap(hp[a], hp[b]);
    return;
}

void down(int u) {
    int t = u;
    while(2 * u <= cnt && h[2 * u] < h[t]) t = 2 * u;
    while(2 * u + 1 <= cnt && h[2 * u + 1] < h[t]) t = 2 * u + 1;
    if(u != t) {
        heap_swap(u, t);
        down(t);
    }
    return;
}

void up(int u) {
    while(u / 2 && h[u] < h[u / 2]) {
        heap_swap(u, u / 2);
        u /= 2;
    }
    return;
}

int main() {
    int n, m = 0;
    cin >> n;
    while(n--) {
        int k, x;
        char op[5];
        scanf("%s", op);
        if(!strcmp(op, "I")) {
            scanf("%d", &x);
            ++cnt, ++m;
            ph[m] = cnt, hp[cnt] = m;
            h[cnt] = x;
            up(cnt);
        }
        else if(!strcmp(op, "PM")) {
            printf("%d\n", h[1]);
        }
        else if(!strcmp(op, "DM")) {
            heap_swap(1, cnt);
            cnt--;
            down(1);
        }
        else if(!strcmp(op, "D")) {
            scanf("%d", &k);
            k = ph[k];
            heap_swap(k, cnt);
            cnt--;
            up(k), down(k);
        }
        else {
            scanf("%d%d", &k, &x);
            k = ph[k];
            h[k] = x;
            up(k), down(k);
        }
    }    
    return 0;
}
```